
<!DOCTYPE html>
<html lang="en">
  
<head>
  <meta charset="UTF-8">
  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          processEscapes: true,
      },
      displayAlign: "left",
      displayIndent: "1em",
      CommonHTML: { linebreaks: { automatic: true } },
      "HTML-CSS": { linebreaks: { automatic: true } },
      SVG       : { linebreaks: { automatic: true } }
    });
</script>
<script type="text/javascript"
        async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  <link rel="stylesheet" href="/css/style.css">
  <title>(Basic) Lazy Evaluation and Memoization in JavaScript</title>
</head>

  <body>
    <main>
    
<header>
  <section class="top">
    <h1>gypsydave5</h1>
    <p>The blog of David Wickes, software developer</p>
  </section>

  <ul class="links">
    <li><a href="/about/">about</a></li>
    <li><a href="/posts/">posts</a></li>
  </ul>
</header>

    
<article>
  <h1>(Basic) Lazy Evaluation and Memoization in JavaScript</h1>
  <time datetime="2015-03-21T21:41" >Mar 21, 2015</time>
  <p>Calculation takes time and effort. If I needed to know what, say</p>

<pre><code>4719340 + 397394
</code></pre>

<p>was (and I didn&rsquo;t have a calculator), it would take a few minutes to work out.
Right now, I don&rsquo;t need to know.  Maybe I&rsquo;ll never need to know. I could put
those two numbers and the <code>+</code> sign on a piece of paper and stick it in my
pocket.</p>

<p><img src="/images/sum.png" alt="4719340 + 397394" /></p>

<p>If I ever wanted to know the answer, I could get the paper out and do
the maths. I should write &lsquo;Answer to silly blog sum&rsquo; on the top of the paper.</p>

<p><img src="/images/sum-with-title.png" alt="4719340 + 397394 with title" /></p>

<p>Now I know what the sum is there for. And why I&rsquo;m carrying a piece of paper around.</p>

<p>That&rsquo;s lazy evaluation - holding on to an expression and only evaluating it when
you need it. It pairs neatly with <strong>memoization</strong> - keeping the results of
evaluated expressions in memory so that you don&rsquo;t have to evaluate them every
time you need their result.</p>

<p>(Which figures as, if I ever do work out what <code>4719340 + 397394</code> is, I never
want to work it out again. Ever.)</p>

<p>Let&rsquo;s take a look at doing some lazy evaluation in JavaScript - in other
languages, such as Clojure, we get <a href="http://clojure.org/sequences">a lot of this baked in</a>, but in JavaScript
there&rsquo;s some work to do. Let&rsquo;s take a simple function:</p>

<pre><code class="language-javascript">function add (a, b) {
  return a + b;
}
</code></pre>

<p>And we&rsquo;d like to make that function lazy - with another function, naturally.
Something like:</p>

<pre><code class="language-javascript">var addThisLater = lazyEval( add, 4, 5 );

addThisLater() //=&gt; 9
</code></pre>

<p><code>lazyEval()</code> takes a function name, some more arguments, and returns a function
that, when it evaluates, returns the result of evaluating the passed in function
with the other arguments.</p>

<p>So far so good - but what needs to be returned from <code>lazyEval()</code> to make it work as
described above? As it turns out, not that much:</p>

<pre><code class="language-javascript">function lazyEval (fn) {
  return fn.bind.apply(fn, arguments);
}
</code></pre>

<p>And this is where things get exciting. We&rsquo;ve <a href="/posts/2015/2/19/%28not-quite%29-currying-in-javascript/">seen <code>bind()</code> before</a>, so
let&rsquo;s take a look at <code>apply()</code>, what happens when we chain it with <code>bind()</code>, and
what&rsquo;s happening with <code>arguments</code> keyword.</p>

<h3><code>apply()</code></h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply()</code></a> is pretty simple - it&rsquo;s a method that all functions have. It takes
two arguments. When its evaluated it returns the result of evaluating the
function within the scope of the first argument (just like <code>bind()</code>). The second
argument is an array (or an array-like object - that&rsquo;s important) of arguments
for the function to be evaluated with. Which all sounds scary, but if I do this:</p>

<pre><code class="language-javascript">add.apply(this, [ 1, 2 ]) //=&gt; 3
</code></pre>

<p>I hope that begins to makes more sense. Now let&rsquo;s take a closer look at <code>arguments</code>.</p>

<h3><code>arguments</code> and Argument Binding</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a> is an array-like object (it lacks a number of methods that arrays
have) which contains, unsurprisingly, all of the arguments passed to the current
function you&rsquo;re in the scope of - even ones not bound to a variable.</p>

<p>JavaScript functions, unlike some other languages, can take as many parameters
as you like. Which means that this:</p>

<pre><code class="language-javascript">add(1, 2) //=&gt; 3
</code></pre>

<p>works just like this:</p>

<pre><code class="language-javascript">add(1, 2, 'peace', ['love'], { and: 'understanding' }) //=&gt; 3
</code></pre>

<p><code>add()</code> binds its first two arguments to <code>a</code> and <code>b</code>. Those extra arguments get
ignored - <code>add()</code> just goes on adding as usual. But that does not mean that
those arguments go nowhere. They&rsquo;re still available to the function in the
<code>arguments</code> <del>array</del> array-like object.</p>

<p>Look, try this:</p>

<pre><code class="language-javascript">function echo () {
  return arguments
}

echo(1) //=&gt; { 0: 1 }

echo('peace', ['love'], { and: 'understanding' })
//=&gt; { '0': 'peace','1': [ 'love' ], '2': { and: 'understanding' } }

echo('faith', 'hope', 'charity')[2] //=&gt; 'charity'
</code></pre>

<p>OK, back on track. When <code>apply(fn, arguments)</code> is evaluated, it is passing the
arguments <code>fn, 4, 5</code> along to the function that <code>apply()</code> is being called
on. Namely, in this case, <code>bind()</code>.</p>

<p>(As a comparison, if <code>apply()</code> was replaced by its close cousin, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call()</code></a>,
which takes more traditional looking arguments, it would look like this:
<code>bind.call(fn, fn, 4, 5)</code>)</p>

<p><code>fn, 4, 5</code> gets passed along to <code>bind()</code>, where <code>fn</code> becomes the <code>this</code> argument
for <code>bind()</code>, providing the scope, and the <code>4, 5</code> get bound as the arguments of
the function that <code>bind()</code> is being called on (in our examples, <code>add()</code>). And so
we get the <code>add()</code> function back, but with all its arguments already bound,
ready to be evaluated with a flick of our <code>()</code>.</p>

<h3>Memoization</h3>

<p>All of which is great, but what&rsquo;s the point if you have to evaluate the function
every time it&rsquo;s called? Wouldn&rsquo;t it be better if the function &lsquo;remembered&rsquo; the
result, and returned the remembered result the second time it was called rather
than evaluating it all over again? Or, to continue the increasingly strained
example, I should write the answer down on my piece of paper once I&rsquo;ve worked it
out the first time, rather than having to do the sum every time I need to know
the answer.</p>

<p>And that&rsquo;s <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>, a way of optimizing code so that it will return cached
results for the same inputs. This might get a little more complicated with
functions that have more than one input, but for our little <code>lazyEval</code> function
it&rsquo;s not all that hard (there&rsquo;s no arguments at all!):</p>

<pre><code class="language-javascript">function lazyEvalMemo (fn) {
  var args = arguments;
  var result;
  var lazyEval = fn.bind.apply(fn, args);
  return function () {
    if (result) {
      console.log(&quot;I remember this one!&quot;);
      return result
    }
    console.log(&quot;Let me work this out for the first time...&quot;);
    result = lazyEval()
    return result;
  }
}
</code></pre>

<p>Let&rsquo;s give it a function - a <code>sum</code> that does a little reporting for us&hellip;</p>

<pre><code class="language-javascript">function sum (a, b) {
  console.log(&quot;I'm calculating!&quot;);
  return a + b;
}
</code></pre>

<p>And let it rip!</p>

<pre><code class="language-javascript">var lazyMemoSum = lazyEvalMemo(sum, 4719340, 397394)

lazyMemoSum()
//=&gt; Let me work this out for the first time...
//=&gt; I'm calculating!
//=&gt; 5116734

lazyMemoSum()
//=&gt; I remember this one!
//=&gt; 5116734
</code></pre>

<p>It does the calculation the first time, and every subsequent call uses the
memoized result.</p>

</article>

    </main>
  </body>
</html>
