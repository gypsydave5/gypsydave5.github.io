
<!DOCTYPE html>
<html lang="en">
  
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          processEscapes: true,
      },
      displayAlign: "left",
      displayIndent: "1em",
      CommonHTML: { linebreaks: { automatic: true } },
      "HTML-CSS": { linebreaks: { automatic: true } },
      SVG       : { linebreaks: { automatic: true } }
    });
</script>
<script type="text/javascript"
        async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  <link rel="stylesheet" href="/css/style.css">
  <title>Lambda Calculus 3 - Arithmetic with Church Numbers</title>
</head>

  <body>
    <main>
    
<header>
  <section class="top">
    <h1><a href="/">gypsydave5</a></h1>
    <p>The blog of David Wickes, software developer</p>
  </section>

  <ul class="links">
    <li><a href="/pages/about/">about</a></li>
    <li><a href="/posts/">posts</a></li>
  </ul>
</header>

    
<article>
  <h1>Lambda Calculus 3 - Arithmetic with Church Numbers</h1>
  <time datetime="2017-09-23T20:54" >Sep 23, 2017</time>
  <p>Previously I&rsquo;ve posted about <a href="/posts/2017/9/11/lambda-calculus-1---syntax/">the lambda calculus</a>
and <a href="/posts/2017/9/13/lambda-calculus-2---church-numbers/">Church numbers</a>. We&rsquo;d shown how we can encode numbers as
functions using the Church encoding, but we&rsquo;d not really shown how we could <em>do</em>
anything with those numbers.</p>

<p>But before we get into it, let&rsquo;s clear up some stuff about brackets&hellip;</p>

<h2>Left association and you</h2>

<p>Just as it&rsquo;s easier to write $\lambda nfx.$ than $\lambda n.\lambda f.\lambda x.$
because we make the assumption that each application of the function returns
a new function, so there is a way of writing out function application without
having to use lots of parentheses.<sup class="footnote-ref" id="fnref:1"><a rel="footnote" href="#fn:1">1</a></sup></p>

<p>Where we would normally write</p>

<p>$$
f(x)
$$</p>

<p>with parentheses, we could instead write</p>

<p>$$
f\ x
$$</p>

<p>under the assumption that each argument associates to the one on the left. So if
we had</p>

<p>$$
((f(x)\ y)\ z)
$$</p>

<p>we can write it as</p>

<p>$$
f\ x\ y\ z
$$</p>

<p>and something like</p>

<p>$$
(g(x)\ f(x))
$$</p>

<p>is</p>

<p>$$
g\ x\ (f\ x)
$$</p>

<p>As we still need the parentheses to make sure that the $f$ and $x$ get bundled
together. We&rsquo;ll need this convention as we go on as things are going to get a
little more parenthesis-heavy.</p>

<h2>Add-one</h2>

<p>OK, let&rsquo;s get back to the arithmetic.</p>

<p>Say we have the number three:</p>

<p>$$
three \ \equiv \ \lambda f \lambda x.\ f\ (f\ (f x))
$$</p>

<p>(the function $f$ applied to $x$ three times)</p>

<p>And we wanted to get to the number four:</p>

<p>$$
four \ \equiv \ \lambda f \lambda x.\ f\ (f (f\ (f x)))
$$</p>

<p>(the function $f$ applied to $x$ four times)</p>

<p>How do we get from $three$ to $four$? Well, the difference is that we just need
to apply $f$ one more time.</p>

<p>$$
four \ \equiv \ f\ three
$$</p>

<p>We can encode the idea of applying $f$ one more time into a lambda function. We
could call it $add-one$ or $increment$ but lets go with $succ$ for &lsquo;successor&rsquo;.</p>

<p>$$
succ \ \equiv \ \lambda n. \lambda f. \lambda x.\ f\ (n\ f\ x)
$$</p>

<p>The $n$ is the number we&rsquo;re adding one to - we need to bind in the values of $f$
and $x$ in to the function because they&rsquo;ll need to have $n$ applied to them
before we can apply $f$ in the one extra time.</p>

<p>Another way to think of this is that the general signature for a number is
$\lambda f. \lambda x.$, and that when we apply $succ$ to a number, we need to
get back another number - something else with the signature of $\lambda f. \lambda\ x.$</p>

<p>So the signature of $succ$ - and consequently any unary operation on a
number - is $\lambda n.\lambda f.\lambda x$, where $n$ is the number being changed.</p>

<p>In Clojure that looks like:</p>

<pre><code class="language-clojure">(fn [n] (fn [f] (fn [x] (f ((n f) x))))))
</code></pre>

<p>Yeah, it&rsquo;s a bit <em>verbose</em> in comparison to the lambda calculus version.<sup class="footnote-ref" id="fnref:2"><a rel="footnote" href="#fn:2">2</a></sup> All
those parentheses, while great for being explicit about which functions get
applied to what, makes it a bit tough on the eyes.</p>

<p>What about Haskell?</p>

<pre><code class="language-haskell">\n f x -&gt; f (n f x)
</code></pre>

<p>Bit more like the original, eh? Haskell has currying and left-association baked
in to its syntax so its lambda expressions look almost exactly the same as the
lambda calculus ones. You can see why it&rsquo;s so popular.<sup class="footnote-ref" id="fnref:3"><a rel="footnote" href="#fn:3">3</a></sup></p>

<h2>Addition</h2>

<p>Let&rsquo;s see if we can define addition.</p>

<p>First off, $addition$ is an operation that takes two arguments, two numbers. So
we know it needs to look something like:</p>

<p>$$
\lambda m. \lambda n. \lambda f. \lambda x.
$$</p>

<p>Where $m$ and $n$ are the numbers being added together. Now all we need to do is
work out what comes after the dot.</p>

<p>We could define it in terms of $succ$ - all we need to do is apply $succ$
$m$ many times to $n$:</p>

<p>$$
\lambda m.\lambda n.\lambda f.\lambda x.\ m\ succ\ n\ f\ x
$$</p>

<p>And this works,<sup class="footnote-ref" id="fnref:5"><a rel="footnote" href="#fn:5">4</a></sup> but we could probably write something both more intuitive
and simpler.</p>

<p>What do we want as the result of $add$? We want a function that applies $f$ to
$x$ $n$ many times, and the applies $f$ to the result of that $m$ many times.</p>

<p>$$
add\ (\lambda fx.\ f\ (f\ x))\ (\lambda fx.\ f\ (f\ (f\ x))) = \lambda fx.\ f\ (f\ (f\ (f\ (f\ x))))
$$</p>

<p>We can just write that out with the variables we&rsquo;ve been given - first apply $f$
to $x$, $n$ many times.</p>

<p>$$
n\ f\ x
$$</p>

<p>and then apply $f$ to that result $m$ many times</p>

<p>$$
m\ f\ (n\ f\ x)
$$</p>

<p>giving us</p>

<p>$$
add\ \equiv\ \lambda n.\lambda m.\lambda f.\lambda x.\ m\ f\ (n\ f\ x)
$$</p>

<p>The order of $n$ and $m$ doesn&rsquo;t matter as they&rsquo;re just the order in which the
number of $f$s are applied.<sup class="footnote-ref" id="fnref:6"><a rel="footnote" href="#fn:6">5</a></sup></p>

<h2>Multiplication</h2>

<p>We&rsquo;ve used the word &lsquo;times&rsquo; a lot here when talking about the application of $f$
onto $x$s in the above. But now we&rsquo;ll have to deal with real multiplication.</p>

<p>Before you try and reach at an answer, step back a little and ask yourself what
the result ought to be, and what the Church arithmetic way of describing it would
be.</p>

<p>Say we had the numbers two and three. If I was back in primary school I&rsquo;d say
that the reason that multiplying them together made six was because six was &lsquo;two
lots of three&rsquo; or &lsquo;three lots of two&rsquo;.</p>

<p>So when I want to put this into Church arithmetic, I feel like saying &lsquo;six is
the application of three lots of the application of two lots of the application
of $f$ onto $x$&rsquo;. Which is a mouthful, for sure, but looks like</p>

<p>$$
six\ \equiv\ \lambda f.\lambda x.\ ((three\ (two\ f))\ x)
$$</p>

<p>or, without the parentheses</p>

<p>$$
six\ \equiv\ \lambda f.\lambda x.\ three\ (two\ f)\ x
$$</p>

<p>$two\ f$ is a function that applies $f$ two times to whatever it&rsquo;s next argument
is. $three\ (two\ f)$ will apply $two\ f$ to its next argument three times. So it
will apply it $3\ \times\ 2$ times - 6 times.</p>

<p>And so now we can move from the particular case to the general case;
multiplication is:</p>

<p>$$
mult\ \equiv\ \lambda m.\lambda n.\lambda f.\lambda x.\ m\ (n\ f)\ x
$$</p>

<p>&rdquo;$m$ lots of ($n$ lots of $f$) applied to $x$&ldquo;, which is still a mouthful but</p>

<h2>Exponentiation</h2>

<p>So what could exponentiation be? Well, the first thing we know is that this
time, order <em>is</em> going to be important - $2^3$ is not the same as $3^2$.</p>

<p>Next, what does exponentiation <em>mean</em>? I mean, really mean? When we did
multiplication we saw us doing &lsquo;two lots of (three lots of $f$)&rsquo;. But now we
need to do &lsquo;two lots of something&rsquo; three times. The &lsquo;three&rsquo; part has to apply,
not to the number of times we do an $f$, nor the number of times we do &lsquo;$n$ lots
of $f$&rsquo;. But rather it needs to be <em>the number of times we do $n$ to itself</em>.</p>

<p>Woah.</p>

<p>So if &lsquo;three&rsquo; is the application of $f$ three times to $x$, we can say that
$2^3$ is the application of $two$ three times to $f\ x$.</p>

<p>Even. Bigger. Woah.</p>

<p>Another way to look at it: a Church number is already encoding some of the
behaviour of exponentiation. When we use <code>inc</code> and <code>0</code> as <code>f</code> and <code>x</code> we can
think of the number <code>n</code> acting as $inc^n$ - <code>inc</code> done to itself <code>n</code> many times.</p>

<p>This is more explicit if we try it with something other than increment - say
<code>double</code>, aka &lsquo;times two&rsquo;. Let&rsquo;s do it in Haskell - but please feel free to pick
any language you like.</p>

<pre><code class="language-haskell">let timesTwo = \x -&gt; 2 * x
let four = \f x -&gt; f(f(f(f x)))

four timesTwo 1 -- 16
</code></pre>

<p>Four lots of <code>timesTwo</code> is 16; all we need to do is to use the number two
instead, and apply the result to an <code>f</code> and an <code>x</code>.</p>

<pre><code class="language-haskell">let two = \f x -&gt; f(f x)
four two succ 0 -- 16
</code></pre>

<p>Sixteen again.</p>

<p>So function for exponentiation - <code>m</code> to the power of <code>n</code> - is:</p>

<p>$$
exp\ \equiv\ \lambda m.\lambda n.\lambda f.\lambda x.\ n\ m\ f\ x
$$</p>

<p>But remember $\eta$-reduction? We can just go directly to:</p>

<p>$$
exp\ \equiv\ \lambda m.\lambda n.\ n\ m
$$</p>

<p>This is because you know the function you&rsquo;re left with after you&rsquo;ve applied $n$
to $m$ is a number - will take an $f$ and an $x$ - you don&rsquo;t need to explicitly
bind them in the outer function just in order to pass them unchanged to the
inner one.</p>

<p>But that&rsquo;s just a nicety. The important thing is&hellip; we&rsquo;ve finished!</p>

<h2>Summary and Next!</h2>

<p>This post looked at some simple arithmetic using Church numerals. We saw successor</p>

<p>$$
succ\quad \equiv\quad \lambda n.\lambda f.\lambda x.\ f\ (n\ f\ x)
$$</p>

<p>addition:</p>

<p>$$
add\quad \equiv\quad \lambda m.\lambda n.\lambda f.\lambda x.\ m\ f\ (n\ f\ x)
$$</p>

<p>multiplication:</p>

<p>$$
mult\quad \equiv\quad \lambda m.\lambda n.\lambda f.\lambda x.\ m\ (n\ f)\ x
$$</p>

<p>and exponentiation:</p>

<p>$$
exp\quad \equiv\quad \lambda m.\lambda n.\ m\ n
$$</p>

<p>An interesting relationship between the last three: the $f$ moves along to the
right as the operation becomes &lsquo;bigger&rsquo;.</p>

<p>Next post we&rsquo;ll be taking a short break from arithmetic to take a look at logic
using the lambda calculus.</p>

<div class="footnotes">

<hr />

<ol>
<li id="fn:1">And I&rsquo;m speaking as a mad Lisp fan, lover of parens where ever they are.</li>

<li id="fn:2"><p>But still terse compared to the mess we&rsquo;d get in Python. Or Ruby. Yeah, don&rsquo;t try it in Ruby. Oh, and I guess we could use the short hand anonymous
function syntax, but I think that&rsquo;d look even messier&hellip;</p></li>

<li id="fn:3">For functional programming that is.</li>

<li id="fn:5">Get your pencil and paper out if you want to prove it!</li>

<li id="fn:6">The same will go for multiplication. We know that this has to be the case if we&rsquo;re representing these numbers and operations correctly as they should display the <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative property</a></li>
</ol>

</div>

</article>

    </main>
  </body>
</html>
