<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="rss.xml"
      title="RSS feed for "/>
<title>Kotlin is Terrible</title>
<meta name="author" content="John Dow">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div class="header">
  <a href="https://staticblog.org">My Static Org Blog</a>
</div></div>
<div id="content">
<div class="post-date">16 Sep 2020</div><h1 class="post-title"><a href="/kotlin-a-case-against-syntactic-sugar.md.html">Kotlin is Terrible</a></h1>
<p>
I've been writing a lot of Kotlin at work for the last three months.
Nice shiny new job, nice shiny new language. And for the most part it is
nice and shiny. Think Groovy meets Scala with a sprinkling of something
like Rust or Go.
</p>

<p>
But I'm intolerant in my old age. If you're going to create a new
language in the 21st Century it'd be nice if you didn't make design
decisions that make me want to scream.
</p>

<div id="outline-container-orgdd87dd1" class="outline-2">
<h2 id="how-do-you-say-function">How do you say 'function'?</h2>
<div class="outline-text-2" id="text-how-do-you-say-function">
<p>
Kotlin is partly sold as a more 'functional' Java. Not as functional as
Scala, but getting there.
</p>

<p>
So how do you write a function?
</p>

<pre class="example">
fun addTwo (number: Int): Int {
  return number + 2
}
</pre>

<p>
That's nice and easy - just like C or Go or Java!
</p>

<p>
But maybe that's a bit too verbose - we could just return the result
as&#x2026; an assignment?
</p>

<pre class="example">
fun addTwo (number: Int): Int = number + 2
</pre>

<p>
So now I'd like to use this nice named function to <code>map</code> over a list.
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(addTwo)
</pre>

<p>
This, of course, doesn't work. Because &#x2026; wait, what? Why doesn't this
work?
</p>

<p>
Well even though that thing looks like a function, it's going to get
compiled down to some Java bytecode which will turn it into a method on
a class. I have no idea how that happens - but I imagine it's something
like using a different lookup table for variables and functions like we
get in Common Lisp.
</p>

<p>
So we need to reference the function like this:
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(::addTwo)
</pre>

<p>
Just&#x2026; just do it. Don't ask why.
</p>

<p>
But what if I just wanted to inline <code>addTwo</code>, like I was writing a
futuristic language like JavaScript?
</p>

<p>
Easy - you just pass in a <code>lambda</code>. These just look like they do in
Groovy, but in Groovy they were called closures.
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map({number -&gt; number + 2})
</pre>

<p>
You don't even need to use the parenthesese if the last argument to your
function is a Lambda - it can look just like Ruby.
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map { number -&gt; number + 2 }
</pre>

<p>
And to really round off the fun, we can get rid of <code>number</code> and replace
it with the default receiver - <code>it</code>. Like Groovy!
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map { it + 2 }
</pre>

<p>
Notice how there's no <code>return</code> in a lambda? It's just like Rust or Ruby
or whatever - each lambda just evaluates to the final expression.
</p>

<p>
In fact, if you <i>do</i> return from a lambda, you'll actually be returning
from the outer function. How useful is that! You'll end up only mapping
over <i>one</i> of the numbers.
</p>

<p>
If you really <i>want</i> to return from the lambda - or block, did I say
that they're sometimes called blocks when they're the last argument?
It's good to have more that one name for the same thing, right? So if
you really want to return early you can use the <code>return@map</code> syntax.
</p>

<p>
Or, you know, use an anonymous function.
</p>

<p>
Oh, did I not mention anonymous functions? They're just like functions,
and lambdas, and closures, and blocks except they have a different
syntax <i>and return works</i>.
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(fun (number: Int): Int { return number + 2 })
</pre>

<p>
Or we make it an expression &#x2026; in which case we don't have to return
it&#x2026;
</p>

<pre class="example">
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(fun (number: Int): Int = number + 2)
</pre>

<p>
And I've not even mentioned that it's possible to stick an <code>invoke</code>
method on objects to make them behave like functions รก la Scala:
</p>

<pre class="example">
object addTwo {
    invoke(number: Int) = number + 2
}

val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(addTwo)
</pre>
</div>
</div>

<div id="outline-container-org47b3fc1" class="outline-2">
<h2 id="so-what-dave">So what, Dave?</h2>
<div class="outline-text-2" id="text-so-what-dave">
<p>
Am I against having different solutions to problems? Certainly not? Do I
hate either implicit or explicit returns? No, nothing that specific.
</p>

<p>
What's grinding my gears is the confusion between the 'Lambda' syntax
and the 'Anonymous Function' syntax. Here the language is letting you
write the same concept - the anonymous function - in two different ways.
And the only discernable advantage of one syntax over the other is the
introduction of the keyword <code>return</code> - the behaviour of each is (or at
least can be made) identical.
</p>

<p>
The saddening part of this that the language has taken the core
(arguably) functional language primitive and made it into two different
things. Both syntaxes reference the same programming concept, but just
by there being two of them the language is introducing an unnecessary
confusion.
</p>

<p>
And that confusion is important, because a (programming) language is a
language we should be able to express ourselves in clearly, without
ambiguity.
</p>
</div>
</div>
<div class="taglist"></div></div>
<div id="postamble" class="status"><div id="archive">
  <a href="https://staticblog.org/archive.html">Other posts</a>
</div>
<center><a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">bastibe.de</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://bastibe.de" property="cc:attributionName" rel="cc:attributionURL">Bastian Bechtold</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</center></div>
</body>
</html>
