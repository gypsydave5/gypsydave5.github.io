---
layout: post
title:  "Many Enumerable Returns"
date:   2014-05-14 20:52:15
categories: Ruby RubyMonk
---

As threatened then, here's the followup to my last post on the #Enumerables
section from [Ruby Monk][RubyMonk], how I felt like a bit of an idiot, and what I learned from that.

This question is a little further along from the last, and was framed so:

> Try implementing a method called occurrences that accepts a string argument and
> uses inject to build a Hash. The keys of this hash should be unique words from
> that string. The value of those keys should be the number of times this word
> appears in that string.

So far so, so good. So I wrote this:

{% highlight Ruby %}
def occurrences(str)
  str.scan(/\w+/).inject(Hash.new(0)) do |hash, i|
    hash[i.downcase] += 1
  end
end
{% endhighlight %}

Which spat out:

> TypeError
> can't convert String into Integer

And left me confused for a good few minutes. OK, getting on for a quarter of an
hour. What was going on - what I'd written was very similar to the example
above:

{% highlight ruby %}
[4, 8, 15, 16, 23, 42].inject({}) { |a, i| a.update(i => i) }
{% endhighlight %}

So I caved and looked at the answer:

{% highlight ruby %}
def occurrences(str)
	str.scan(/\w+/).inject(Hash.new(0)) do |build, word|
  	build[word.downcase] +=1
  	build
	end
end
{% endhighlight %}

Which left me none the wiser. Why was the block re-iterating the accumulator
function at the end? To test this I played around with `p`-ing the lines of the
block... and discovered something interesting. Namely,

{% highlight ruby %}

a.update(i => i) # => a

# But...

build[word.downcase] +=1 # => build[word.downcase], the new value of that key

{% endhighlight %}

The block *needs* to return the accumulator - the first example is just lucky
that it does so already!

The reason the accumulator in an `Enumerable#inject` accumulates is that *it's
returned from the block on each iteration*. In other words, somewhere in the
definition of `#inject` for each class that can be made enumerable, the method
`yield`s to the block, and then keeps the value returned to be passed in again
as the new accumulator argument.

I'd previously thought of `#inject` as working by *magic*, whereas in fact it was
working by a method I could probably write myself given enough time. Something
like (entirely untested).

{% highlight ruby %}
def inject(default = nil)
    accumulator = default || self[0]
    self.each do |element|
       yield (accumulator, element)
    end
    accumulator
end
{% endhighlight %}

I relied on `#each` here, but we could easily write an `each` method using
a `for... in...` loop or similar. The genius is in `yield`, which is the real
magic that's going on here.

[RubyMonk]: https://rubymonk.com/
[RMHashMap]: https://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/44-collections/lessons/98-iterate-filtrate-and-transform#solution4313
[destructuring]: http://tony.pitluga.com/2011/08/08/destructuring-with-ruby.html
[Lisp]: http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node252.html
[splat]: http://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/
[WRR]: http://www.manning.com/black2/
[double-splat]: http://stackoverflow.com/questions/18289152/what-does-double-splat-operators-do-in-ruby
